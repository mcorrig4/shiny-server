---
title: "Ski Case"
output: html_notebook
---

## Load Data
```{r}
data.set <- read.csv("Whistler Blackcomb Exhibit1.csv", skip = 2)
data.set <- data.set[1:93, ]
colnames(data.set)[5] <- "Prebookings"
colnames(data.set)[6] <- "Actual.Demand"
colnames(data.set)[7] <- "Holiday"
colnames(data.set)[8] <- "Matched.DOW"
```


## Regression
#### Test Day-Matching Theory

Lets view the matched days as a time series
```{r}
library(plotly)
library(ggplot2)
names(data.set)
plot_ly(data.set, x = ~Day.of.Season, y = ~Actual.Demand, 
        name = 'Actual Demand', type = 'scatter', mode = 'lines') %>%
  add_trace(y = ~Matched.DOW, name = 'Matched Day', mode = 'lines+markers') 

```

### Next Lets plot the days against eachother to see if there is some corrolation
```{r}
actualDemand <- data.set$Actual.Demand
matchedDemand <- data.set$Matched.DOW
plot(matchedDemand ~ actualDemand, 
     xlab = "Actual Demand", 
     ylab = "Past Demand 1998-1999", 
     main = "Demand Matched on Day of Week", 
     col = "blue")
m <- lm(matchedDemand ~ actualDemand)
abline(m, col="red")
legend(x='bottomright', legend=paste('Cor =',round(summary(m)$r.squared,2)))

```

### Make a function to filter each day and see if certain days match up better
```{r}
library(dplyr)
filterDays <- function(df, days = c("Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun")) {
  f <- filter(df, Day.of.Week == days)
  return(f)
}
```

### Loop through the days of the week to see if any days match up better
```{r}
days <- c("Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun")
for (i in 1:length(days)) {
  filtered <- filterDays(data.set, days[i])
  ad <- filtered$Actual.Demand
  md <- filtered$Matched.DOW
  plot(md ~ ad, 
     xlab = "Actual Demand", 
     ylab = "Past Demand 1998-1999", 
     main = paste("Demand Matched on", days[i]), 
     col = "blue")
  lm.filtered <- lm(md ~ ad)
  abline(lm.filtered, col="red")
  legend(x='bottomright', legend=paste('Cor =',round(summary(lm.filtered)$r.squared,2)))
}
```

### It looks like the middle of the week has better day-matching correlation, lets map r^2 values to check
```{r}
r2Value <- NULL
for (i in 1:length(days)) {
  filtered <- filterDays(data.set, days[i])
  ad <- filtered$Actual.Demand
  md <- filtered$Matched.DOW
  lm.filtered <- lm(md ~ ad)
  r2 <- summary(lm.filtered)$r.squared
  r2Value <- c(r2Value, r2)
}
barplot(r2Value, main="R^2 Values", names.arg=days, cex.names=0.8)
```

### The weekend definitely isn't a good time to use day matching to predict actual demand!!

# Linear Models with multiple variables
### use leaps to figure out the best variable to keep in the model

```{r}
library(leaps)
model.allsubsets <- regsubsets(Actual.Demand ~ Prebookings + Matched.DOW + 
                                 Exchange.Rate.USD.CAD + Exchange.Rate.GBP.CAD, 
                               data = data.set)
summary(model.allsubsets)
summary(model.allsubsets)$bic 
```
### Using the step function to find the best things to keep in the model

```{r}
#stepwise selection
null <- lm(Actual.Demand ~ 1, data = data.set)
full <- lm(Actual.Demand ~ Prebookings + Matched.DOW + 
             Exchange.Rate.USD.CAD + Exchange.Rate.GBP.CAD, 
           data = data.set)
step(null, scope = list(lower = null, upper = full), direction="both")
```
### Use it again with the new best model to add another variable to the model
```{r}
#stepwise selection
null <- lm(Actual.Demand ~ Prebookings, data = data.set)
full <- lm(Actual.Demand ~ Prebookings + Matched.DOW + 
             Exchange.Rate.USD.CAD + Exchange.Rate.GBP.CAD, 
           data = data.set)
step(null, scope = list(lower = null, upper = full), direction="both")

```

# ANOVA
### run a bunch of anova test on different models


```{r}
m0 <- lm(Actual.Demand ~ 1, data = data.set)
m1 <- lm(Actual.Demand ~ Prebookings, data = data.set)
m2 <- lm(Actual.Demand ~ Matched.DOW, data = data.set)
m3 <- lm(Actual.Demand ~ Prebookings + Matched.DOW, data = data.set)

anova(m0, m1)
```
```{r}
anova(m0, m2)
```
```{r}
anova(m0, m3)

```

```{r}
anova(m0, m1, m2, m3)
```
### Therefore we reject the null hypothesis for all these test and these models are all good

## Forward selecting variable to include in the model
```{r}
#forward selection
model.current = lm(data.set$Actual.Demand ~ 1)
add1(model.current, ~ data.set$Prebookings + data.set$Matched.DOW + 
       data.set$Exchange.Rate.USD.CAD + data.set$Exchange.Rate.GBP.CAD, test="F")
```

### F = MSR/MSE
#### Prebookings sum of square is almost equal to the f value meaning MSE is very small 
#### Matching day of the week SS is much bigger than the F value so MSE is larger in this case

### Can conclude that prebookings has less unexplainable error (so better?)
### Or is day of week matching because sum of squares is lower?

```{r}
# Choose the independent variable with the lowest p-value
model.current = lm(data.set$Actual.Demand ~ data.set$Prebookings)
add1(model.current, ~ data.set$Prebookings + data.set$Matched.DOW + 
       data.set$Exchange.Rate.USD.CAD + data.set$Exchange.Rate.GBP.CAD, test="F")
```
```{r}
model.current = lm(data.set$Actual.Demand ~ data.set$Matched.DOW)
add1(model.current, ~ data.set$Prebookings + data.set$Matched.DOW + 
       data.set$Exchange.Rate.USD.CAD + data.set$Exchange.Rate.GBP.CAD, test="F")
```

## Forecasting

```{r}
pred <- predict(lm(Actual.Demand ~ Matched.DOW + Prebookings, data = data.set[1:92, ]), 
                data.set[93, ],interval="prediction", level=0.95)
pred
```
#### based on a model including Previous year and Prebooking numbers we can expect to need [48 to 62] instructors with 95% confidence
### We should book 55 instructors 



## Periodic Forecasting

### Using Decompose
```{r}
library(fpp)
library(Ecdat)

ts_ski0 <- ts(data.set$Matched.DOW, start = c(1998, 11, 22), frequency = 7)
ts_ski1 <- ts(data.set$Actual.Demand[1:92], start = c(1999, 11, 22), frequency = 7)

decompose_ski0 = decompose(ts_ski0)
decompose_ski1 = decompose(ts_ski1)
#decompose_ski1 = decompose(ts_ski1, "additive") 

plot(as.ts(decompose_ski0$seasonal))
plot(as.ts(decompose_ski0$trend))
plot(as.ts(decompose_ski0$random))
plot(decompose_ski0)
plot(decompose_ski1)
```

### Using STL
```{r}

stl_ski0 = stl(ts_ski0, "periodic")
seasonal_stl_ski0   <- stl_ski0$time.series[,1]
trend_stl_ski0     <- stl_ski0$time.series[,2]
random_stl_ski0  <- stl_ski0$time.series[,3]
 
plot(ts_ski0)
plot(as.ts(seasonal_stl_ski0))
plot(trend_stl_ski0)
plot(random_stl_ski0)
plot(stl_ski0, main = "1998-1999")
```
#### Looks like some bigger error around christmas time and university break week


```{r}
stl_ski1 = stl(ts_ski1, "periodic")
seasonal_stl_ski1   <- stl_ski1$time.series[,1]
trend_stl_ski1     <- stl_ski1$time.series[,2]
random_stl_ski1  <- stl_ski1$time.series[,3]
 
plot(ts_ski1)
plot(as.ts(seasonal_stl_ski1))
plot(trend_stl_ski1)
plot(random_stl_ski1)
plot(stl_ski1, main = "1999-2000")
```



# Link to Shiny app
[Link to shiny app](http://r.liamcorrigan.com:3838/)
